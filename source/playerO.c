#include <nds.h>
#include <stdio.h>
#include <gl2d.h>

#include "global.h"
#include "playerO.h"
#include "uvcoord_player.h"

    

void InitializePlayer(Player* player) {

    // Basic Struct Variables

	player->x = 16 * 5;
	player->y = 16 * 4;
	player->height = 30;
	player->width = 20;

    // Physics Variables

	player->gravity = 0.4;
	player->jump = -7;
    player->acceleration = 0.4;
    player->decceleration = 0.6;
	player->speed_x = 0;
	player->speed_y = 0;
    player->speed_cap_x = 5;
    player->speed_cap_y = 7;
    player->on_floor = false;

    // Logic Variables

    player->state = P_IDLE;

    // Animation and Graphics Variables
	player->texture_id = glLoadSpriteSet( player->textures,			// pointer to glImage array
						 PLAYER_NUM_IMAGES, 		// Texture packer auto-generated #define
						 player_texcoords,		// Texture packer auto-generated array
						 GL_RGB256,				// texture type for glTexImage2D() in videoGL.h 
						 TEXTURE_SIZE_512,		// sizeX for glTexImage2D() in videoGL.h
						 TEXTURE_SIZE_32,		// sizeY for glTexImage2D() in videoGL.h
						 GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
						 256,					// Length of the palette to use (256 colors)
						 (u16*)playerPal,		// Load our 256 color crono palette
						 (u8*)playerBitmap		// image data generated by GRIT
					   );
    player->animation_state = P_ANIM_IDLE;
    player->hflip = GL_FLIP_NONE;
    player->image_index = 0;
    player->is_walking = false;

	InitInventory(player->inventory);


}

void PlayerLogic(Player* player, unsigned short map[MAP_WIDTH][MAP_HEIGHT], int key, int prev_key) {

	player->speed_x = 0;

	if (!(prev_key & KEY_SELECT) && (key & KEY_SELECT)) {
		ShiftActiveSlotRight(player->inventory);
	}

	if (key & KEY_RIGHT)
	{
		player->speed_x = 1;
		player->is_walking = true;
		player->hflip = GL_FLIP_H;
	}
		
	if (key & KEY_LEFT)
	{
		player->speed_x = -1;
		player->is_walking = true;
		player->hflip = GL_FLIP_NONE; 
	}

	if (key & KEY_UP && player->on_floor)
	{
		player->speed_y = player->jump;
		player->on_floor = false;
	}

	player->speed_y += player->gravity;
		
	if (player->speed_y > 7) {
		player->speed_y = 7;
	}

	DetectPlayerCollision(map, player);
		
}

void DetectHorizontalCollision(unsigned short blocks_array[MAP_WIDTH][MAP_HEIGHT], Player* p, int x, int y) {

	if (p->speed_x == 0) {
		return;
	}

	int tile_x;
	int tile_y;
	//Horizontal Collision
	if (p->speed_x > 0) {
		tile_x = (x + p->width + p->speed_x) / 16;			
		tile_y = y / 16;
		if (blocks_array[tile_x][tile_y] != 0) {
			p->x = tile_x * 16 - p->width;
			p->speed_x = 0;
		}
	}
	else {
		tile_x = (x + p->speed_x) / 16;			
		tile_y = y / 16;
		if (blocks_array[tile_x][tile_y] != 0) {
			p->x = (tile_x+1) * 16;
			p->speed_x = 0;
		}
	}
}

void DetectVerticalCollision(unsigned short blocks_array[MAP_WIDTH][MAP_HEIGHT] , Player* p, int x, int y) { 

	if (p->speed_y == 0) {
		return;
	}


	int tile_x;
	int tile_y;
	//Vertical Collision

	if (p->speed_y > 0) {
		tile_x = x / 16;			
		tile_y = (y + p->height + p->speed_y) / 16;
		if (blocks_array[tile_x][tile_y] != 0) {
			p->y = tile_y * 16 - p->height;
			p->speed_y = 0;
			p->on_floor = true;
		}
		if (blocks_array[tile_x][tile_y] == 0) {
			p->on_floor = false;
		}
	}
	else {
		tile_x = x / 16;			
		tile_y = (y + p->speed_y) / 16;
		if (blocks_array[tile_x][tile_y] != 0) {
			p->y = (tile_y + 1) * 16;
			p->speed_y = 0;
		}
	}
}

void DetectPlayerCollision(unsigned short map[MAP_WIDTH][MAP_HEIGHT] , Player* p) {

	DetectHorizontalCollision(map, p, p->x, p->y);
	DetectHorizontalCollision(map, p, p->x, p->y+16);

	p->x += p->speed_x;

	DetectVerticalCollision(map, p, p->x , p->y);
	DetectVerticalCollision(map, p, p->x + 16, p->y);

	p->y += p->speed_y;	
}

void DrawPlayer(Player* player, int camera_x, int camera_y) { 
    glSpriteRotate(player->x - camera_x + player->width /2, player->y - camera_y + player->height /2, 0, player->hflip , &player->textures[0]);
}