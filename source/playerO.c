#include <nds.h>
#include <stdio.h>
#include <gl2d.h>

#include "playerO.h"
#include "uvcoord_player.h"
    

Player* InitializePlayer() {
    
    Player *player = malloc(sizeof(Player));

    // Basic Struct Variables

	player->x = 16 * 5;
	player->y = 16 * 4;
	player->height = 30;
	player->width = 20;

    // Physics Variables

	player->gravity = 0.4;
	player->jump = -7;
    player->acceleration = 0.4;
    player->decceleration = 0.6;
	player->speed_x = 0;
	player->speed_y = 0;
    player->speed_cap_x = 5;
    player->speed_cap_y = 7;
    player->on_floor = false;

    // Logic Variables

    player->state = P_IDLE;

    // Animation and Graphics Variables
	player->texture_id = glLoadSpriteSet( player->textures,			// pointer to glImage array
						 PLAYER_NUM_IMAGES, 		// Texture packer auto-generated #define
						 player_texcoords,		// Texture packer auto-generated array
						 GL_RGB256,				// texture type for glTexImage2D() in videoGL.h 
						 TEXTURE_SIZE_512,		// sizeX for glTexImage2D() in videoGL.h
						 TEXTURE_SIZE_32,		// sizeY for glTexImage2D() in videoGL.h
						 GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
						 256,					// Length of the palette to use (256 colors)
						 (u16*)playerPal,		// Load our 256 color crono palette
						 (u8*)playerBitmap		// image data generated by GRIT
					   );
    player->animation_state = P_ANIM_IDLE;
    player->hflip = GL_FLIP_NONE;
    player->image_index = 0;
    player->is_walking = false;
    
	return player;

}

void PlayerLogic(Player* player, Map* map, int key) {

	player->speed_x = 0;

	if (key & KEY_RIGHT)
	{
		player->speed_x = 1;
		player->is_walking = true;
		player->hflip = GL_FLIP_H;
	}
		
	if (key & KEY_LEFT)
	{
		player->speed_x = -1;
		player->is_walking = true;
		player->hflip = GL_FLIP_NONE; 
	}

	if (key & KEY_UP && player->on_floor)
	{
		player->speed_y = player->jump;
		player->on_floor = false;
	}

	player->speed_y += player->gravity;
		
	if (player->speed_y > 7) {
		player->speed_y = 7;
	}

	DetectPlayerCollision(map, player);
		
}

void DetectHorizontalCollision(Map* map, Player* p, int x, int y) {
	int tile_x;
	int tile_y;
	//Horizontal Collision
	if (p->speed_x > 0) {
		tile_x = (x + p->width + p->speed_x) / 16;			
		tile_y = y / 16;
		if (map->blocks_array[tile_x][tile_y] != 0) {
			p->x = tile_x * 16 - p->width;
			p->speed_x = 0;
		}
	}
	else {
		tile_x = (x + p->speed_x) / 16;			
		tile_y = y / 16;
		if (map->blocks_array[tile_x][tile_y] != 0) {
			p->x = (tile_x+1) * 16;
			p->speed_x = 0;
		}
	}
}

void DetectVerticalCollision(Map* map, Player* p, int x, int y) { 
	int tile_x;
	int tile_y;
	//Vertical Collision

	if (p->speed_y > 0) {
		tile_x = x / 16;			
		tile_y = (y + p->height + p->speed_y) / 16;
		if (map->blocks_array[tile_x][tile_y] != 0) {
			p->y = tile_y * 16 - p->height;
			p->speed_y = 0;
			p->on_floor = true;
		}
		if (map->blocks_array[tile_x][tile_y] == 0) {
			p->on_floor = false;
		}
	}
	//else {
	//	tile_x = x / 16;			
	//	tile_y = (y + p->speedy) / 16;
	//	if (map[tile_x][tile_y] != 0) {
	//		p->y = (tile_y+1) * 16;
	//		p->speedy = 0;
	//	}
	//}
}

void DetectPlayerCollision(Map* map, Player* p) {

	DetectHorizontalCollision(map, p, p->x, p->y);
	DetectHorizontalCollision(map, p, p->x, p->y+16);

	p->x += p->speed_x;

	DetectVerticalCollision(map, p, p->x , p->y);
	DetectVerticalCollision(map, p, p->x + 16, p->y);

	p->y += p->speed_y;	
}

void DrawPlayer(Player* player,Camera* camera) {
    glSpriteRotate(player->x - camera->x + player->width /2, player->y - camera->y + player->height /2, 0, player->hflip , &player->textures[0]);
}