#include <nds.h>
#include <stdio.h>
#include <gl2d.h>

#include "mapO.h"

Map* InitMap()
{
	Map *map  = malloc(sizeof(Map));

    map->width = MAP_WIDTH;		// init map dimesions
	map->height = MAP_HEIGHT;

	map->texture_id = 
		glLoadTileSet( map->tiles_images,		// pointer to glImage array
					   16,					// sprite width
					   16,					// sprite height
					   256,					// bitmap width
					   256,					// bitmap height
					   GL_RGB256,			// texture type for glTexImage2D() in videoGL.h 
					   TEXTURE_SIZE_256,	// sizeX for glTexImage2D() in videoGL.h
					   TEXTURE_SIZE_256,	// sizeY for glTexImage2D() in videoGL.h
					   GL_TEXTURE_WRAP_S|GL_TEXTURE_WRAP_T|TEXGEN_OFF|GL_TEXTURE_COLOR0_TRANSPARENT, // param for glTexImage2D() in videoGL.h
					   256,					// Length of the palette to use (256 colors)
					   (u16*)tilesPal,		// Load our 256 color tiles palette
					   (u8*)tilesBitmap		// image data generated by GRIT
					 );


	int x, y, dist;
	for (y = 0; y < MAP_HEIGHT; y++)
	{
		for (x = 0; x < MAP_WIDTH; x++) 
		{
			map->blocks_array[x][y] = 1;
			dist = (x%4) & 255;

			if (y < 6+dist) {
				map->blocks_array[x][y] = 0;
			}
			if (y == 6+dist) {
				map->blocks_array[x][y] = 2;
			}

			map->blocks_array[x][y] &= 255;
			
		}
	}

	return map;

}

void MapInteraction(CursorPointer* cursor_pointer, Map* map, int key) {

    int block_index = map->blocks_array[cursor_pointer->x / 16][cursor_pointer->y / 16];


    switch (block_index)
    {
        case -1:
        break;
    
        default:
            if (key & KEY_R) {
                map->blocks_array[cursor_pointer->x / 16][cursor_pointer->y / 16] = 0;
            }
            if (key & KEY_L) {
                map->blocks_array[cursor_pointer->x / 16][cursor_pointer->y / 16] = 1;
            }
        break;
    }
    
}

// Draws a full screen map
void DrawMap(Map* map, Camera* camera)
{
	// tiles are 16x16 pixels
	const int TILE_SIZE = 16;
 
	// calculate number of tiles per row and column
	const int SCREEN_TILE_X = SCREEN_WIDTH / TILE_SIZE;
	const int SCREEN_TILE_Y = SCREEN_HEIGHT / TILE_SIZE;
	
	int x, y;				// counters
	int tile_x, tile_y;		// current tile to draw
	int screen_x, screen_y;	// actual screen position (in pixel)
	int i;					// tile index to draw
	
	// we need to draw an extra tile at the bottom and right 
	// since we are scrolling
	for (y = 0; y <= SCREEN_TILE_Y; y++)
	{
		for (x = 0; x <= SCREEN_TILE_X; x++) 
		{
			tile_x = camera->tile_x + x;		// get relative tile positions
			tile_y = camera->tile_y + y;
			i = map->blocks_array[tile_x][tile_y];		// get map index
			screen_x = (x * TILE_SIZE) - camera->pixel_x;      //Calculate where to put a
            screen_y = (y * TILE_SIZE) - camera->pixel_y;      //particular tile
			glSprite(screen_x, screen_y, GL_FLIP_NONE , &map->tiles_images[i]);
		}
	}
	
	
}

